# Longest Substring Without Repeating Characters  
ðŸ”— LeetCode #3

---

## Problem Summary
Given a string `s`, find the length of the **longest substring without repeating characters**.

---


## My O(n) Solution (Sliding Window)

### Idea
- Use two pointers `l` and `r`
- Maintain a set of current window characters
- Shrink the window when a duplicate appears
- Keep track of the maximum size

### Code
```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {

        unordered_set<char> uset;

        if(s.size() == 0) return 0;
        if(s.size() == 1) return 1;

        int res = 0;
        int l = 0;

        uset.insert(s[l]);

        for(int r = 1; r < s.size(); r++)
        {
            while(uset.count(s[r]) == 1)
            {
                res = max(res, (int)uset.size());
                uset.erase(s[l]);
                l++;
            }
            uset.insert(s[r]);
        }

        return max(res, (int)uset.size());
    }
};
```

### Complexity
- **Time:** O(n)
- **Space:** O(n)

---
## My O(nÂ²) Solution (Brute Force)

### Idea
- Start from each index `L`
- Try to extend the substring to the right
- Stop when a duplicate appears
- Track the maximum length

### Code
```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int maxCounter = 0;

        for(int L = 0; L < s.size(); L++)
        {
            unordered_set<char> upure;
            int counter = 0;

            int R = L + 1;
            upure.insert(s[L]);
            counter++;

            if(upure.count(s[R]) == 1 && R < s.size())
            {
                upure.insert(s[R]);
                R++;
                counter++;
            }
            maxCounter = max(counter, maxCounter);
        }
        return maxCounter;
    }
};
```

### Complexity
- **Time:** O(nÂ²)
- **Space:** O(n)

---

## Optimal O(n) Solution (Clean Sliding Window)

### Idea
- Use `left` and `right` pointers
- Expand window with `right`
- Shrink from `left` until no duplicates
- Window length = `right - left + 1`

### Key Line
```cpp
maxLength = max(maxLength, right - left + 1);
```

### Code
```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int left = 0;
        int maxLength = 0;
        unordered_set<char> charSet;

        for (int right = 0; right < s.length(); right++) {
            while (charSet.find(s[right]) != charSet.end()) {
                charSet.erase(s[left]);
                left++;
            }

            charSet.insert(s[right]);
            maxLength = max(maxLength, right - left + 1);
        }

        return maxLength;        
    }
};
```

### Complexity
- **Time:** O(n)
- **Space:** O(n)

---

## Final Notes
- Sliding Window is the key pattern here
- Each character is added and removed at most once
- This guarantees linear time complexity

---
