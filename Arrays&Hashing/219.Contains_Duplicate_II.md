# LeetCode 219 – Contains Duplicate II

## Problem Statement
Given an integer array `nums` and an integer `k`, return `true` if there are two distinct indices `i` and `j` such that:

- `nums[i] == nums[j]`
- `|i - j| <= k`

Otherwise, return `false`.

---

## Optimal Solution – Sliding Window + Hash Set

### Idea
- Maintain a sliding window of size `k`
- Store only the last `k` elements
- If a number already exists in the window → duplicate within range

### Code
```cpp
class Solution {
public:
    bool containsNearbyDuplicate(vector<int>& nums, int k) {
        unordered_set<int> window;

        for (int i = 0; i < nums.size(); i++) {
            if (window.count(nums[i])) {
                return true;
            }

            window.insert(nums[i]);

            if (window.size() > k) {
                window.erase(nums[i - k]);
            }
        }
        return false;
    }
};
```

### Time & Space Complexity
- Time: **O(n)**
- Space: **O(k)**

---

## My Solution – Hash Map (Index Tracking)

### Idea
- Store the last index of each number
- When the same number appears again:
  - Check the distance between indices

### Code
```cpp
class Solution {
public:
    bool containsNearbyDuplicate(vector<int>& nums, int k) {
        unordered_map<int, int> umap;

        for (int i = 0; i < nums.size(); i++) {
            if (umap.find(nums[i]) != umap.end() &&
                abs(umap[nums[i]] - i) <= k) {
                return true;
            } else {
                umap[nums[i]] = i;
            }
        }
        return false;
    }
};
```

### Time & Space Complexity
- Time: **O(n)**
- Space: **O(n)**

---

## Comparison

| Aspect | Sliding Window + Set | Hash Map |
|------|---------------------|----------|
| Extra Space | O(k) | O(n) |
| Logic | Simple | More conditional |
| Tracks Indices | ❌ | ✅ |
| Optimal | ✅ | ❌ |

---

## Conclusion
The sliding window + unordered_set approach is the most optimal solution for this problem.
