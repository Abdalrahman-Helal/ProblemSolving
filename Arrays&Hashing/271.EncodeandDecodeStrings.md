# Encode and Decode Strings

## üß© Problem Description
Design an algorithm to **encode** a list of strings to a single string and **decode** it back to the original list of strings.

üîó **LeetCode Link:**  
https://leetcode.com/problems/encode-and-decode-strings/

---

## üß† My Approach (Delimiter-Based Encoding)

This approach concatenates all strings using a special delimiter (`;`) and splits them back during decoding.

### Idea:
- **Encode:** Join all strings using `;`
- **Decode:** Split the encoded string whenever `;` is found

‚ö†Ô∏è This approach assumes that the delimiter character (`;`) does **not appear inside the strings**.

---

## ‚úÖ My C++ Implementation

```cpp
class Solution {
public:
    string encode(vector<string>& strs) {
        string encoded;

        for (string s : strs) {
            encoded += s;
            encoded += ';';
        }
        return encoded;
    }

    vector<string> decode(string s) {
        vector<string> decoded;
        string h;

        for (char c : s) {
            if (c == ';') {
                decoded.push_back(h);
                h = "";
            } else {
                h += c;
            }
        }
        return decoded;
    }
};
````

---

## üöÄ Optimal Approach (Length-Based Encoding)

This is the **most robust and optimal solution**.

### Idea:

* Encode each string as:

  ```
  length + '#' + string
  ```
* During decoding, read the length first, then extract the exact number of characters.

### Why this is optimal?

* Works with **any characters**
* No delimiter collision
* Used in real systems and interviews

---

## ‚úÖ Optimal C++ Implementation

```cpp
class Solution {
public:
    string encode(vector<string>& strs) {
        string encoded;
        for (string& s : strs) {
            encoded += to_string(s.size()) + "#" + s;
        }
        return encoded;
    }

    vector<string> decode(string s) {
        vector<string> decoded;
        int i = 0;

        while (i < s.size()) {
            int j = i;
            while (s[j] != '#') {
                j++;
            }

            int len = stoi(s.substr(i, j - i));
            string word = s.substr(j + 1, len);
            decoded.push_back(word);

            i = j + 1 + len;
        }

        return decoded;
    }
};
```

---

## ‚è±Ô∏è Complexity Analysis

| Approach               | Time   | Space  |
| ---------------------- | ------ | ------ |
| Delimiter-Based        | `O(n)` | `O(n)` |
| Length-Based (Optimal) | `O(n)` | `O(n)` |

---


