# üîÅ Reverse Linked List (LeetCode)

This repository contains multiple approaches to solve the **Reverse Singly Linked List** problem in C++.

The goal is to reverse a singly linked list and return the new head.

---

## üìå Problem Definition

Given the head of a singly linked list, reverse the list and return the reversed list.

Example:

```
Input:
1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí 5 ‚Üí nullptr

Output:
5 ‚Üí 4 ‚Üí 3 ‚Üí 2 ‚Üí 1 ‚Üí nullptr
```

---

# ‚úÖ My Solution (Iterative ‚Äì Pointer Reversal)

This solution reverses the linked list by manually changing node pointers while traversing the list.

## üíª Code

```cpp
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        
        if(head == nullptr)
        {
            return nullptr;
        }
        
        ListNode* currNode = head;
        ListNode* prevNode = nullptr;
        ListNode* nextNode = nullptr;

        while(currNode != nullptr)
        {
           nextNode = currNode->next;
           currNode->next = prevNode;
           prevNode = currNode;
           currNode = nextNode;
        }
        return prevNode;
    }
};
```

---

## üß† Idea

We maintain three pointers:

* `currNode` ‚Üí Current node
* `prevNode` ‚Üí Previous node (builds reversed list)
* `nextNode` ‚Üí Temporarily stores next node

---

## ‚ö° Fast Trace

### Initial State

```
currNode = 1
prevNode = nullptr
```

---

### Iteration 1

```
nextNode = 2
1 ‚Üí nullptr
prevNode = 1
currNode = 2
```

---

### Iteration 2

```
nextNode = 3
2 ‚Üí 1
prevNode = 2
currNode = 3
```

---

### Iteration 3

```
3 ‚Üí 2 ‚Üí 1
prevNode = 3
currNode = nullptr
```

---

### ‚úÖ Return

```
prevNode ‚Üí New Head
```

---

## ‚è± Complexity

* Time Complexity: **O(n)**
* Space Complexity: **O(1)**

---

# üöÄ Short Iterative Solution

This solution is logically identical but written in a more compact way.

## üíª Code

```cpp
ListNode* node = nullptr;

while (head != nullptr) {
    ListNode* temp = head->next;
    head->next = node;
    node = head;
    head = temp;
}

return node;
```

---

## üß† Idea

Same logic as previous solution but uses:

* `node` ‚Üí acts as previous pointer
* `head` ‚Üí acts as current pointer

---

## ‚ö° Fast Trace

```
Start:
head = 1 ‚Üí 2 ‚Üí 3
node = nullptr
```

### Step 1

```
temp = 2
1 ‚Üí nullptr
node = 1
head = 2
```

### Step 2

```
temp = 3
2 ‚Üí 1
node = 2
head = 3
```

### Step 3

```
temp = nullptr
3 ‚Üí 2 ‚Üí 1
node = 3
head = nullptr
```

Return `node`.

---

## ‚è± Complexity

* Time Complexity: **O(n)**
* Space Complexity: **O(1)**

---

# üîÑ Recursive Solution

This approach reverses the linked list using recursion.

## üíª Code

```cpp
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if (!head || !head->next) {
            return head;
        }

        ListNode* newHead = reverseList(head->next);
        head->next->next = head;
        head->next = nullptr;
        return newHead;        
    }
};
```

---

## üß† Idea

The recursive solution works by:

1. Reversing the rest of the list.
2. Fixing the current node at the end.

---

## ‚ö° Fast Recursive Trace

### Example List

```
1 ‚Üí 2 ‚Üí 3 ‚Üí nullptr
```

---

### Recursive Calls Stack

```
reverse(1)
   reverse(2)
      reverse(3)
```

---

### Base Case

```
reverse(3)
returns 3
```

---

### Unwinding the Stack

#### Returning to Node 2

```
head = 2
newHead = 3

head->next->next = head
3 ‚Üí 2

head->next = nullptr
2 ‚Üí nullptr
```

Now:

```
3 ‚Üí 2 ‚Üí nullptr
```

---

#### Returning to Node 1

```
head = 1
newHead = 3

head->next->next = head
2 ‚Üí 1

head->next = nullptr
```

Final result:

```
3 ‚Üí 2 ‚Üí 1 ‚Üí nullptr
```

---

## ‚è± Complexity

* Time Complexity: **O(n)**
* Space Complexity: **O(n)** (due to recursion stack)

---

# üìä Comparison

| Approach                | Time | Space | Notes                  |
| ----------------------- | ---- | ----- | ---------------------- |
| Iterative (My Solution) | O(n) | O(1)  | Most efficient         |
| Short Iterative         | O(n) | O(1)  | Cleaner syntax         |
| Recursive               | O(n) | O(n)  | Elegant but uses stack |

---

# ‚≠ê Key Learning Points

* Reversing a linked list requires **pointer manipulation**
* Always store next node before modifying pointers
* Iterative solutions are more memory efficient
* Recursive solutions are easier to understand conceptually

---


