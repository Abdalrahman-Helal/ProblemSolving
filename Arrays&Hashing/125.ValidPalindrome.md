# Valid Palindrome

## ğŸ§© Problem Description
Given a string `s`, determine if it is a **palindrome**, considering only alphanumeric characters and ignoring cases.

- Ignore all non-alphanumeric characters
- Case-insensitive

ğŸ”— **LeetCode Link:**  
https://leetcode.com/problems/valid-palindrome/

---

## ğŸ§  My Approach (ASCII Filtering + Reverse Check)

This solution:
- Iterates through the string
- Filters only alphanumeric characters (using ASCII codes)
- Converts uppercase letters to lowercase
- Checks palindrome by comparing characters from both ends

---

## âœ… My C++ Implementation

```cpp
class Solution {
public:
    bool isPalindrome(string s) {
        string palindrome;
        for(char c : s) {
            int ascii= int(c);
            if( (ascii >= 48 && ascii <=57) ||(ascii >= 65 && ascii <=90) ||(ascii >= 97 && ascii <=122)) {
                if((ascii >= 65 && ascii <=90)) {
                    ascii += 32; // convert uppercase to lowercase
                }
                palindrome += char(ascii);
            }
        }

        for(int i = 0; i < palindrome.size(); i++) {
            if(palindrome[i] != palindrome[palindrome.size() - i - 1]) {
                return false;
            }
        }
        return true;
    }
};
````

---

## ğŸš€ Optimal Approach (Using `isalnum` + Two-Pointers)

This solution:

* Uses `isalnum` to filter alphanumeric characters
* Uses `tolower` for lowercase conversion
* Checks palindrome using **two-pointer technique**, avoiding extra space for reverse string

---

## âœ… Optimal C++ Implementation

```cpp
class Solution {
public:
    bool isPalindrome(string s) {
        string filtered;
        for (char c : s) {
            if (isalnum(c)) {
                filtered += tolower(c);
            }
        }

        int left = 0;
        int right = filtered.size() - 1;

        while (left < right) {
            if (filtered[left] != filtered[right]) {
                return false;
            }
            left++;
            right--;
        }

        return true;        
    }
};
```

---

## â±ï¸ Complexity Analysis

| Approach                           | Time   | Space  |
| ---------------------------------- | ------ | ------ |
| ASCII Filtering + Reverse Check    | `O(n)` | `O(n)` |
| Two-Pointers + `isalnum` (Optimal) | `O(n)` | `O(n)` |

---

