# Find Pivot Index

## ðŸ§© Problem Description
Given an array of integers `nums`, return the **pivot index** of this array.

The pivot index is the index where the **sum of all the numbers strictly to the left** of the index is equal to the **sum of all the numbers strictly to the right** of the index.

- If no such index exists, return `-1`
- If there are multiple pivot indexes, return the **left-most** one

ðŸ”— **LeetCode Link:**  
https://leetcode.com/problems/find-pivot-index/

---

## ðŸ§  My Approach (Prefix Sum)

This approach uses a **prefix sum array** to calculate left and right sums efficiently.

### Idea:
- Build a prefix sum array where each index stores the sum up to that position.
- For each index `i`:
  - Left sum = sum of elements before `i`
  - Right sum = total sum âˆ’ prefix sum at `i`
- Compare left and right sums to determine the pivot index.

---

## âœ… My C++ Implementation

```cpp
class Solution {
public:
    int pivotIndex(vector<int>& nums) {
        vector<int> prefArr = prefSum(nums);
        int end = prefArr.size() - 1;

        for (int i = 0; i < nums.size(); i++) {
            if (i == 0) {
                if (prefArr[end] - prefArr[i] == 0)
                    return i;
            }
            else if (i == end) {
                if (prefArr[end - 1] == 0)
                    return i;
            }
            else {
                if (prefArr[i - 1] == prefArr[end] - prefArr[i])
                    return i;
            }
        }
        return -1;
    }

    vector<int> prefSum(vector<int>& arr) {
        int n = arr.size();
        vector<int> prefixSum(n);

        prefixSum[0] = arr[0];
        for (int i = 1; i < n; i++) {
            prefixSum[i] = prefixSum[i - 1] + arr[i];
        }
        return prefixSum;
    }
};
```

---

## ðŸš€ Optimal Approach (Running Sum)

This solution avoids extra space by keeping track of:
- `total` sum of the array
- `leftTotal` sum while iterating

At each index:
```
rightTotal = total - leftTotal - nums[i]
```

If `leftTotal == rightTotal`, the current index is the pivot.

---

## âœ… Optimal C++ Implementation

```cpp
class Solution {
public:
    int pivotIndex(vector<int>& nums) {
        int total = accumulate(nums.begin(), nums.end(), 0);
        int leftTotal = 0;

        for (int i = 0; i < nums.size(); ++i) {
            int rightTotal = total - leftTotal - nums[i];
            if (rightTotal == leftTotal) {
                return i;
            }
            leftTotal += nums[i];
        }

        return -1;
    }
};
```

---

## â±ï¸ Complexity Analysis

| Approach | Time | Space |
|--------|------|-------|
| Prefix Sum | `O(n)` | `O(n)` |
| Optimal Running Sum | `O(n)` | `O(1)` |

---

## ðŸ“ Notes
- Prefix sum solution is intuitive and easy to debug.
- Optimal solution is more memory-efficient.
- Both solutions pass all LeetCode test cases.

â­ If this helped you, consider starring the repository!
