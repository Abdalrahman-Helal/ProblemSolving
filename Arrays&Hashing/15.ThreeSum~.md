# ThreeSum Problem in C++

This repository contains a C++ implementation of the **ThreeSum problem**, which finds all unique triplets in an array that sum up to zero.

---

## Problem Description

Given an array `nums` of `n` integers, find **all unique triplets** `[a, b, c]` such that:

ðŸ”— **LeetCode Link:**  
https://leetcode.com/problems/3sum/

---

```
a + b + c = 0
```

**Note:**

* The solution set must not contain duplicate triplets.

**Example:**

```
Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]
```

---

## Idea / Approach

1. **Sort the array** to make it easier to avoid duplicates and use two pointers.
2. Iterate through the array with index `i`.

   * Skip duplicates for `i` to avoid repeating the same triplet.
3. For each `i`, use **two pointers**:

   * `j` starts at `i + 1`
   * `k` starts at the end of the array.
4. Calculate the sum: `sum = nums[i] + nums[j] + nums[k]`

   * If `sum > 0`, decrease `k` (move left to reduce sum)
   * If `sum < 0`, increase `j` (move right to increase sum)
   * If `sum == 0`, store the triplet and move both pointers while skipping duplicates.
5. Continue until all triplets are found.

This approach reduces the time complexity to **O(nÂ²)**.

---

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> res;

        sort(nums.begin(), nums.end());

        for(int i = 0; i < nums.size(); i++)
        {
            if(i > 0 && nums[i] == nums[i-1])
            {
                continue; // Skip duplicate elements for i
            }

            int j = i + 1;
            int k = nums.size() - 1; 

            while(j < k)
            {
                int sum = nums[i] + nums[j] + nums[k];
                if(sum > 0)
                {
                    k--; // Need smaller sum
                }
                else if(sum < 0)
                {
                    j++; // Need larger sum
                }
                else
                {
                    res.push_back({nums[i],nums[j],nums[k]});
                    j++;
                    k--;

                    // Skip duplicate elements for j
                    while(j < k && nums[j] == nums[j-1])
                        j++;

                    // Skip duplicate elements for k
                    while(j < k && nums[k] == nums[k+1])
                        k--;
                }
            }
        }
        return res;
    }
};
```

---

## Example Trace

**Input:** `nums = [-1, 0, 1, 2, -1, -4]`

1. **Sort the array:** `nums = [-4, -1, -1, 0, 1, 2]`

2. Start iterating with `i = 0` (`nums[i] = -4`)

   * `j = 1` (`-1`), `k = 5` (`2`)
   * Sum = `-4 + (-1) + 2 = -3` â†’ increase `j` â†’ `j = 2`
   * Sum = `-4 + (-1) + 2 = -3` â†’ increase `j` â†’ `j = 3`
   * Sum = `-4 + 0 + 2 = -2` â†’ increase `j` â†’ `j = 4`
   * Sum = `-4 + 1 + 2 = -1` â†’ increase `j` â†’ `j = 5` â†’ stop (j >= k)

3. `i = 1` (`nums[i] = -1`)

   * `j = 2` (`-1`), `k = 5` (`2`)
   * Sum = `-1 + (-1) + 2 = 0` â†’ add `[-1,-1,2]` to result
   * Move `j` â†’ `3`, move `k` â†’ `4`
   * Sum = `-1 + 0 + 1 = 0` â†’ add `[-1,0,1]` to result

4. `i = 2` â†’ skip (duplicate `-1`)

5. `i = 3` (`nums[i] = 0`)

   * `j = 4` (`1`), `k = 5` (`2`)
   * Sum = `0 + 1 + 2 = 3` â†’ decrease `k` â†’ `4` â†’ stop (j >= k)

**Result:** `[[-1,-1,2],[-1,0,1]]`

---

## Complexity Analysis

* **Time Complexity:** O(nÂ²) â†’ outer loop + two-pointer iteration
* **Space Complexity:** O(1) extra space (excluding the result array)
