# Valid Parentheses

## üß© Problem Description
Given a string `s` containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is **valid**.

A string is valid if:
1. Open brackets must be closed by the same type of brackets.
2. Open brackets must be closed in the correct order.

üîó **LeetCode Link:**  
https://leetcode.com/problems/valid-parentheses/

---

## üß† My Approach (Switch & Stack)

This solution uses:
- A `stack` to keep track of opening brackets
- A `switch` statement for each type of bracket
- A counter `i` to track stack size (optional)

### Idea:
- Push opening brackets to the stack
- For closing brackets, check if the top matches the corresponding opening
- Return false if mismatch occurs
- Return true if stack is empty at the end

---

## ‚úÖ My C++ Implementation

```cpp
class Solution {
public:
    bool isValid(string s) {
        stack<char> stck;
        int i = 0;

        for(char c : s) {
            switch(c) {
                case '{': case '[': case '(':
                    stck.push(c);
                    i++;
                    break;

                case ')':
                    if(stck.size() !=0 && stck.top() == '(') { stck.pop(); i--; }
                    else return false;
                    break;

                case ']':
                    if(stck.size() !=0 && stck.top() == '[') { stck.pop(); i--; }
                    else return false;
                    break;

                case '}':
                    if(stck.size() !=0 && stck.top() == '{') { stck.pop(); i--; }
                    else return false;
                    break;
            }
        }

        return i == 0;
    }
};
````

---

## üöÄ Optimal Approach (Mapping + Stack)

This solution uses:

* `unordered_map` to map closing brackets to opening brackets
* Stack to track openings
* Cleaner logic without a counter

---

## ‚úÖ Optimal C++ Implementation

```cpp
class Solution {
public:
    bool isValid(string s) {
        stack<char> stack;
        unordered_map<char, char> mapping = {{')', '('}, {']', '['}, {'}', '{'}};

        for (char c : s) {
            if (mapping.find(c) == mapping.end()) {
                stack.push(c);
            } else if (!stack.empty() && mapping[c] == stack.top()) {
                stack.pop();
            } else {
                return false;
            }
        }

        return stack.empty();
    }
};
```

---

## ‚è±Ô∏è Complexity Analysis

| Approach                  | Time   | Space  |
| ------------------------- | ------ | ------ |
| Switch & Stack            | `O(n)` | `O(n)` |
| Mapping & Stack (Optimal) | `O(n)` | `O(n)` |

---

