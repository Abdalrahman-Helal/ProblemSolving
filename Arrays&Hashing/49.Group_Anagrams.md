# Group Anagrams

## üß© Problem Description
Given an array of strings `strs`, group the **anagrams** together.  
You can return the answer in **any order**.

Two strings are anagrams if they contain the same characters with the same frequencies.

üîó **LeetCode Link:**  
https://leetcode.com/problems/group-anagrams/

---

## üí° Approach (Sorting + Index Tracking)

This solution groups anagrams by **sorting each word alphabetically** and using the sorted version as a key to identify anagram groups.

### Key Ideas:
- Create a copy of the original array to preserve indices.
- Store each word along with its original index.
- Sort characters of each word to generate a comparable form.
- Use a set to identify unique sorted words.
- Group original words that share the same sorted representation.

---

## ‚úÖ C++ Implementation

```cpp
class Solution { 
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {

        vector<vector<string>> matrix;
        vector<string> result;

        vector<string> a = strs;

        /* 
          sortArr -> sorted version of words (alphabetically)
          arr     -> original words with indices
        */
        vector<pair<string,int>> sortArr;
        vector<pair<string,int>> arr;

        int j = 0;
        for (string s : a) {
            arr.push_back({s, j});
            sortArr.push_back({s, j});
            j++;
        }

        for (auto& s : sortArr) {
            sort(s.first.begin(), s.first.end());
        }

        unordered_set<string> uset;
        for (auto& s : sortArr) {
            uset.insert(s.first);
        }

        for (string s : uset) {
            result.clear();
            for (auto& t : sortArr) {
                if (s == t.first) {
                    result.push_back(arr[t.second].first);
                }
            }
            matrix.push_back(result);
        }

        return matrix;
    }
};
```

---

## ‚è±Ô∏è Complexity Analysis

- **Time Complexity:**  
  - Sorting each string: `O(n * k log k)`  
    where `n` = number of strings, `k` = max string length.
- **Space Complexity:** `O(n * k)`

---

## üìù Notes
- Sorting characters is a reliable way to detect anagrams.
- Index tracking allows retrieving original strings correctly.
- This solution is correct but **not the most optimal** compared to a hash-map based approach.

---

‚≠ê Consider optimizing further using:
- `unordered_map<string, vector<string>>`
- Character frequency arrays instead of sorting
